int TriCount;

struct AABB {
    float3 BBMax;
    float3 BBMin;
};

RWStructuredBuffer<uint> Indexes;//TriCount * 3
RWStructuredBuffer<uint> Keys;//TriCount * 3
RWStructuredBuffer<AABB> Input;


inline uint FloatToUint(float f) {
    uint mask = -((int) (asuint(f) >> 31)) | 0x80000000;
    return asuint(f) ^ mask;
}

#pragma kernel PrepKernel
[numthreads(128,1,1)]
void PrepKernel (uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID) {
    if(id.x > TriCount) return;
    float3 Center = (Input[id.x].BBMax + Input[id.x].BBMin) / 2.0f;
    Indexes[id.x * 3] = id.x;
    Indexes[id.x * 3+1] = id.x;
    Indexes[id.x * 3+2] = id.x;
    Keys[id.x * 3] = FloatToUint(Center.x);
    Keys[id.x * 3+1] = FloatToUint(Center.y);
    Keys[id.x * 3+2] = FloatToUint(Center.z);
}

//RADIXA-XDIM,RADIXB-XDIM - no

#pragma kernel HistKernel
//RADIX BINS A{XDIM,YDIM,ZDIM, XDIM,YDIM,ZDIM, XDIM,YDIM,ZDIM} - Radix B{XDIM,YDIM,ZDIM} - 
RWStructuredBuffer<uint> RadixCounts;//256*4*Dim

#define BinRadixSize 256
#define Dim 3
#define BlockSize 64
#define TrisPerThreads 1
#define RadixBins (BinRadixSize / BlockSize)
/*
    Have 256 bins
    * 3 for each dim
    * 4 for each radix

    4 * 256 * 3
*/


/*
0-3 = GT.y
+ GT.x * 4 + i2 = 


*/

groupshared uint LocalBins[RadixBins * BinRadixSize * Dim];
uint ExtractBits256(uint A, uint Selection) {
    return (A >> (Selection * 8)) & 0xFF;
}
//64 threads to play with
//but 256 bins
//so each thread needs to write out to 4 bins
[numthreads(BlockSize,Dim,1)]
void HistKernel (uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID) {
    for(int i = 0; i < 4; i++) {
        LocalBins[GT.y + (GT.x * 4) * Dim + i * BinRadixSize * Dim] = 0;
        LocalBins[GT.y + (GT.x * 4 + 1) * Dim + i * BinRadixSize * Dim] = 0;
        LocalBins[GT.y + (GT.x * 4 + 2) * Dim + i * BinRadixSize * Dim] = 0;
        LocalBins[GT.y + (GT.x * 4 + 3) * Dim + i * BinRadixSize * Dim] = 0;
    }
    GroupMemoryBarrierWithGroupSync();
    for(int i = 0; i < 4; i++) {
        uint Bin = ExtractBits256(Keys[(id.x*Dim+GT.y)], i);
        InterlockedAdd(LocalBins[GT.y + Bin * Dim + i * BinRadixSize * Dim], 1);

        //i * BinRadixSize = offset into RADIX part
        //Bin * Dim = Offset into proper dimensional element
        //GT.y = Offset into final slot
    }
    GroupMemoryBarrierWithGroupSync();
    for(int i = 0; i < 4; i++) {
        InterlockedAdd(RadixCounts[GT.y + (GT.x*4+0) * Dim + i * BinRadixSize * Dim], LocalBins[GT.y + (GT.x*4+0) * Dim + i * BinRadixSize * Dim]);
        InterlockedAdd(RadixCounts[GT.y + (GT.x*4+1) * Dim + i * BinRadixSize * Dim], LocalBins[GT.y + (GT.x*4+1) * Dim + i * BinRadixSize * Dim]);
        InterlockedAdd(RadixCounts[GT.y + (GT.x*4+2) * Dim + i * BinRadixSize * Dim], LocalBins[GT.y + (GT.x*4+2) * Dim + i * BinRadixSize * Dim]);
        InterlockedAdd(RadixCounts[GT.y + (GT.x*4+3) * Dim + i * BinRadixSize * Dim], LocalBins[GT.y + (GT.x*4+3) * Dim + i * BinRadixSize * Dim]);
    }
}


RWStructuredBuffer<uint> PrefixBuffer;
groupshared uint ThreadCompleted[BinRadixSize * Dim];
groupshared uint RunningSum[BinRadixSize * Dim * RadixBins];

///A{XXXXXXX}B{XXXXXX}C{XXXXXXX}D{XXXXXXX}

#pragma kernel ScanKernel
[numthreads(BinRadixSize,Dim,1)]
void ScanKernel (uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID) {
    uint LocalID = GT.x + GT.y * BinRadixSize * RadixBins;
    ThreadCompleted[GT.x + GT.y * BinRadixSize] = 0;
    RunningSum[GT.x + GT.y * BinRadixSize + 0 * BinRadixSize * Dim] = 0;
    RunningSum[GT.x + GT.y * BinRadixSize + 1 * BinRadixSize * Dim] = 0;
    RunningSum[GT.x + GT.y * BinRadixSize + 2 * BinRadixSize * Dim] = 0;
    RunningSum[GT.x + GT.y * BinRadixSize + 3 * BinRadixSize * Dim] = 0;
        int CurOffsetA = RadixCounts[GT.y + GT.x * Dim + 0 * BinRadixSize * Dim];
        int CurOffsetB = RadixCounts[GT.y + GT.x * Dim + 1 * BinRadixSize * Dim];
        int CurOffsetC = RadixCounts[GT.y + GT.x * Dim + 2 * BinRadixSize * Dim];
        int CurOffsetD = RadixCounts[GT.y + GT.x * Dim + 3 * BinRadixSize * Dim];
    if(GT.x == 0) {
        RunningSum[LocalID + 0 * BinRadixSize] = CurOffsetA;
        RunningSum[LocalID + 1 * BinRadixSize] = CurOffsetB;
        RunningSum[LocalID + 2 * BinRadixSize] = CurOffsetC;
        RunningSum[LocalID + 3 * BinRadixSize] = CurOffsetD;
    }
    GroupMemoryBarrierWithGroupSync();

    if(GT.x == 0) {
        ThreadCompleted[GT.x + GT.y * BinRadixSize] = 15;
    }
    AllMemoryBarrierWithGroupSync();
    if(GT.x != 0)
    while(true) {
        uint PrevCheck = ThreadCompleted[GT.x + GT.y * BinRadixSize-1];
        uint CurCheck = ThreadCompleted[GT.x + GT.y * BinRadixSize];
        if(((PrevCheck & ~CurCheck) >> 0) & 0x1) {RunningSum[LocalID + 0 * BinRadixSize] = RunningSum[LocalID-1 + 0 * BinRadixSize] + CurOffsetA; CurCheck |= (1 << 0);}
        if(((PrevCheck & ~CurCheck) >> 1) & 0x1) {RunningSum[LocalID + 1 * BinRadixSize] = RunningSum[LocalID-1 + 1 * BinRadixSize] + CurOffsetB; CurCheck |= (1 << 1);}
        if(((PrevCheck & ~CurCheck) >> 2) & 0x1) {RunningSum[LocalID + 2 * BinRadixSize] = RunningSum[LocalID-1 + 2 * BinRadixSize] + CurOffsetC; CurCheck |= (1 << 2);}
        if(((PrevCheck & ~CurCheck) >> 3) & 0x1) {RunningSum[LocalID + 3 * BinRadixSize] = RunningSum[LocalID-1 + 3 * BinRadixSize] + CurOffsetD; CurCheck |= (1 << 3);}
        

        ThreadCompleted[GT.x + GT.y * BinRadixSize] = CurCheck;
        if(CurCheck == 15) break;
    }
        if(GT.x != 255) {
            PrefixBuffer[LocalID + 0 * BinRadixSize+1] = RunningSum[LocalID + 0 * BinRadixSize];
            PrefixBuffer[LocalID + 1 * BinRadixSize+1] = RunningSum[LocalID + 1 * BinRadixSize];
            PrefixBuffer[LocalID + 2 * BinRadixSize+1] = RunningSum[LocalID + 2 * BinRadixSize];
            PrefixBuffer[LocalID + 3 * BinRadixSize+1] = RunningSum[LocalID + 3 * BinRadixSize];
        }
        if(GT.x == 0) {
            PrefixBuffer[LocalID + 0 * BinRadixSize] = 0;
            PrefixBuffer[LocalID + 1 * BinRadixSize] = 0;
            PrefixBuffer[LocalID + 2 * BinRadixSize] = 0;
            PrefixBuffer[LocalID + 3 * BinRadixSize] = 0;
        }
}

StructuredBuffer<uint> IndexBufferRead;
RWStructuredBuffer<uint> IndexBufferWrite;
RWStructuredBuffer<uint> TileIndexBuffer;
int RADIX;
#pragma kernel SortKernel
groupshared uint LocalOffset[BinRadixSize * Dim];
[numthreads(BinRadixSize,1,1)]
void SortKernel (uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID, uint3 G : SV_GroupID) {
    // if(id.x > TriCount) return;

    int CurTile = 0;

    if(GT.x == 0 && GT.y == 0) InterlockedAdd(TileIndexBuffer[0], 1, CurTile);
    LocalOffset[GT.x * Dim + GT.y] = 0;
    AllMemoryBarrierWithGroupSync();


    uint InIndex = IndexBufferRead[(GT.x + CurTile * 1) * 3 + GT.y];
    uint Bin = ExtractBits256(Keys[InIndex * 3 + GT.y], 0);
    uint LocalID = Bin + GT.y * BinRadixSize * RadixBins;

    int WriteIndex;
    AllMemoryBarrierWithGroupSync();
    int OFFF = 0;
    // while(G.x != TileIndexBuffer[0] && OFFF < 10000) {OFFF++;}
    // InterlockedAdd(PrefixBuffer[Bin], 1, WriteIndex);
    // InterlockedAdd(PrefixBuffer[Bin], 1, WriteIndex);

    AllMemoryBarrierWithGroupSync();


    IndexBufferWrite[InIndex] = WriteIndex;
    GroupMemoryBarrierWithGroupSync();

    InterlockedAdd(PrefixBuffer[LocalID], LocalOffset[GT.x * Dim + GT.y]);
}


// int RADIX;
// #pragma kernel SortKernel
// groupshared uint LocalOffset[BinRadixSize * Dim];
// [numthreads(BinRadixSize,1,1)]
// void SortKernel (uint3 id : SV_DispatchThreadID, uint3 GT : SV_GroupThreadID) {



// }