// #include "UnityCG.cginc"
#include "../GlobalDefines.cginc"

#ifndef DX11
    #pragma use_dxc
    // #pragma enable_d3d11_debug_symbols
#endif
#include "CommonData.cginc"
#include "Materials.cginc"
#include "../Utility/Atmosphere/AtmosphereSampling.cginc"

#ifdef HDRP
    Texture2DArray<float2> MotionVectors;
#else
    Texture2D<float2> MotionVectors;
#endif


#pragma kernel kernel_shade

int BackgroundType;
int SecondaryBackgroundType;
float3 BackgroundColor;
float BackgroundIntensity;
float SecondaryBackgroundIntensity;
bool ImprovedPrimaryHit;
bool ClayMode;
bool UseTransmittanceInNEE;
//These are here purely for the Atrous
#ifdef HardwareRT
    #include "UnityRayQuery.cginc"
    #pragma require inlineraytracing
    RaytracingAccelerationStructure myAccelerationStructure;
#endif
bool VisabilityCheck(SmallerRay ray, float dist) {
    #ifdef HardwareRT
        const uint rayFlags = RAY_FLAG_FORCE_OPAQUE  ;
        UnityRayQuery<rayFlags> q;
        RayDesc myRay;
        myRay.Origin = ray.origin;
        myRay.Direction = ray.direction;
        myRay.TMin = 0;
        myRay.TMax = dist;
        q.TraceRayInline(myAccelerationStructure, rayFlags, 0xff, myRay);
        while(q.Proceed()){}

        if(q.CommittedStatus() == COMMITTED_TRIANGLE_HIT) return false;
        else return true;
    #else
    return VisabilityCheckCompute(ray, dist);
    #endif
}

#ifdef RadianceCache
inline void calcFinalColor(SmallerRay ray, inout ColData Color, MaterialData hitDat, RayHit hit, uint2 id, const float last_pdf, const uint pixel_index, int MaterialIndex, float2 BaseUv, inout float4 PrevScreenData, inout PropogatedCacheData CacheInstance) {//main function
#else
inline void calcFinalColor(SmallerRay ray, inout ColData Color, MaterialData hitDat, RayHit hit, uint2 id, const float last_pdf, const uint pixel_index, int MaterialIndex, float2 BaseUv, inout float4 PrevScreenData) {//main function
#endif
    bool CB = !DoPartialRendering;
    if(!CB) {
        CB = (int(id.x)/2 + int(id.y)/2 + curframe)%PartialRenderingFactor==0;
        if(UseASVGF || (UseReSTIRGI && ReSTIRGIUpdateRate != 0)) {
            if(RandomNums[id].z != 0 || RandomNums[id].w != 0) CB = true;
        }
    }
    float3 PrevOrigin = ray.origin;
    float3 pos = ray.direction * hit.t + ray.origin;
    float3 PrevDirection = ray.direction;
    float3 Geomnorm;
    float3 USGNorm;//Unsmoothed geometric normal
    float3 norm;
    float3x3 Inverse = transpose((float3x3)_MeshData[hit.mesh_id].W2L);
    float pdf = 0.0f;
    bool validBSDFSample;

    float3 throughput = Color.throughput;
    [branch] if (TerrainExists && hit.mesh_id == 9999999) {
        Geomnorm = GetHeightmapNormal(pos, hit.triangle_id);
        USGNorm = Geomnorm;
    } else {
        Geomnorm = GetTriangleNormal(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        USGNorm = mul(Inverse, cross(normalize(AggTris[hit.triangle_id].posedge1), normalize(AggTris[hit.triangle_id].posedge2)));
        float wldScale = rsqrt(dot(USGNorm, USGNorm));
        USGNorm = -mul(wldScale, USGNorm);
        if(dot(USGNorm, Geomnorm) < 0) USGNorm *= -1;
        if(hitDat.MatType == CutoutIndex) USGNorm = Geomnorm;
    }

    bool GotFlipped = dot(ray.direction, USGNorm) > 0.0f;
    if (GotFlipped) {USGNorm *= -1.0f; Geomnorm *= -1.0f;}//Backfacing surface

    Geomnorm = i_octahedral_32(octahedral_32(Geomnorm));
    norm = Geomnorm;

    [branch]if(CurBounce == 0 && UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[id].z != 0 && hitDat.specTrans == 0 && hitDat.diffTrans == 0) {
        norm = i_octahedral_32(asuint(RandomNums[id].w));
#ifdef DebugSlowFixOn
    } else if (CurBounce == 0 && !ClayMode && hitDat.NormalTex.x > 0) {//Handle Normal Maps
#else
    } else if (!ClayMode && hitDat.NormalTex.x > 0) {//Handle Normal Maps
#endif
        float3 LocalTan = GetTriangleTangent(hit.triangle_id, float2(hit.u, hit.v), Inverse);
        float3 LocalBinorm = normalize(cross(Geomnorm, LocalTan));
        float2 Norm = SampleTexture(BaseUv, SampleNormal, hitDat);

        float3 LocalNormIN = float3((hitDat.NormalStrength * Norm - (hitDat.NormalStrength / 2.0f)), 0.0f);
        LocalNormIN.z = 1.0 - 0.5 * dot(LocalNormIN, LocalNormIN);
        norm = clamp(normalize(mul(normalize(LocalNormIN), float3x3(LocalTan, LocalBinorm, Geomnorm)).xyz),-1,1);
        if (abs(norm.x) == abs(norm.y) == abs(norm.z)) norm = Geomnorm;
        norm = i_octahedral_32(octahedral_32(norm));
    }
    if(CurBounce == 0 && UseASVGF && !(hitDat.metallic == 1 && hitDat.roughness < 0.05f) && hitDat.specTrans != 1 && RandomNums[id].w == 1) {
        Geomnorm = i_octahedral_32(asuint(PrevScreenData.x));
        norm = i_octahedral_32(asuint(PrevScreenData.y));
    }


    {
        [branch]if(hitDat.MatCapTex.x > 0 && hitDat.MatCapMask.x > 0) {
            float3 worldViewUp = normalize(float3(0, 1, 0) - ray.direction * dot(ray.direction, float3(0, 1, 0)));
            float3 worldViewRight = normalize(cross(ray.direction, worldViewUp));
            
            float2 matcapUV = float2(dot(worldViewRight, norm), dot(worldViewUp, norm)) * 0.5f + 0.5;

            float4 matcap = SampleTexture(matcapUV, SampleMatCap, hitDat);
            hitDat.surfaceColor = lerp(hitDat.surfaceColor, matcap.xyz, SampleTexture(BaseUv, SampleMatCapMask, hitDat).x);
        }
    }


    [branch] if (hitDat.emmissive > 0.0f) {//if we hit a light, this ray is done
        #ifdef WhiteLights
            hitDat.surfaceColor = 0.5f;
        #endif
        float3 EmissCol = hitDat.surfaceColor * hitDat.emmissive * LEMEnergyScale;
        if (!UseNEE) {
            if (CurBounce <= 1) Color.Direct += EmissCol;
            #ifndef RadianceCache
                if(CurBounce > 1) Color.Indirect += Color.throughput * EmissCol;
            #else
            else {
                if(!((CacheInstance.pathLength >> 5) & 0x1)) Color.Indirect += Color.throughput * EmissCol;
                else CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + EmissCol);
            }
            #endif
        } else {
            float3 a1 = mul((float3x3)inverse(_MeshData[hit.mesh_id].W2L), AggTris[hit.triangle_id].posedge1).xyz;
            float3 a2 = mul((float3x3)inverse(_MeshData[hit.mesh_id].W2L), AggTris[hit.triangle_id].posedge2).xyz;
            float a = AreaOfTriangle(float3(0,0,0), a1, a2);
            float SA = abs(dot(norm, ray.direction)) * a / (hit.t * hit.t);
            float light_pdf = 1.0f / (SA * LightMeshCount);
            #ifdef LBVH
                #ifdef FasterLightSampling
                    light_pdf *= rcp(_MeshData[hit.mesh_id].LightTriCount);
                #else
                    CalcLightPDF(light_pdf, ray.origin, pos, ray.direction, pixel_index, hit.mesh_id);
                #endif
            #else
                light_pdf *= rcp(_MeshData[hit.mesh_id].LightTriCount);
            #endif
            float w = power_heuristic(max(last_pdf,0), light_pdf);
            if (CurBounce == 0) Color.Direct += EmissCol;
            else if (CurBounce == 1) Color.Direct += EmissCol * w;
            #ifndef RadianceCache
                else Color.Indirect += Color.throughput * EmissCol * w;
            #else
            else {
                if(!((CacheInstance.pathLength >> 5) & 0x1)) Color.Indirect += Color.throughput * EmissCol * w;
                else CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + EmissCol * w);
            }
            #endif
        }
        if(CurBounce == 0 && !(id.x == screen_width / 2 && id.y == screen_height / 2)) PrevScreenData.z = -10000.0f;
        if(luminance(EmissCol) > 12.0f) {
            if(CurBounce == 0) {
                Color.Data = EmissCol;
                Color.MetRoughIsSpec = (Color.MetRoughIsSpec & ~(0xFC000000)) |  ((1) << 26);  
            }
            #ifdef RadianceCache
                if(CurBounce > 0)
                if(!UseReSTIRGI || ReSTIRGIUpdateRate == 0 || RandomNums[id.xy].z == 0) {
                    if(!AddHitToCache(CacheInstance, PrevOrigin, random(324, pixel_index).x)) return;
                    CacheInstance.CurrentIlluminance = 0;   
                }
            #endif
            return;
        }
    }
   
    [branch]if(ClayMode) {
        hitDat.surfaceColor = ClayColor;
        hitDat.metallic = 0;
        hitDat.clearcoat = 0;
        hitDat.specTrans = 0;
        hitDat.sheen = 0;
        hitDat.Specular = 0;
    }

    int MaterialLobe = 2;
    bool Refracted = false;
    float3 bsdf = 1;
    [branch] if(CurBounce == 0 && UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[id].z != 0) {
        #ifdef HDRP
            float2 MotionVector = MotionVectors[int3(id,0)].xy;
        #else
           float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, (id) / float2(screen_width, screen_height) , 0).xy;
        #endif
        uint2 prevIndexDoub = int2(floor(((float2(id) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));

        ray.direction = normalize(CalcPos(WorldPosB[prevIndexDoub]) - (pos + USGNorm * NormalOffset));
        MaterialLobe = RandomNums[id].z - 1;
        validBSDFSample = ReconstructBsdf(hitDat, PrevDirection, ray.direction, norm, pdf, bsdf, GetTangentSpace(norm), pixel_index, MaterialLobe);
    } else validBSDFSample = SampleDisney(hitDat, ray.direction, GetFlag(hitDat.Tag, Thin), pdf, bsdf, norm, MaterialLobe, pixel_index, Refracted, GotFlipped);

    {
        if (CurBounce == 0) {
            float Metallic = saturate(hitDat.metallic + ((!UseASVGF || UseReSTIRGI) ? 0 : hitDat.Specular));
            if (MaterialLobe == 3) Color.MetRoughIsSpec = ToColorSpecPackedAdd(float3(0, Refracted ? 0.6f : 0.39f, 2 + !Refracted), Color.MetRoughIsSpec);
            else Color.MetRoughIsSpec = ToColorSpecPackedAdd(float3(Metallic, hitDat.roughness, MaterialLobe), Color.MetRoughIsSpec);
        }

        if (Refracted) {
            Geomnorm *= -1;
            norm *= -1;
            USGNorm *= -1;
            CB = true;
        } else if (GetBounceData(Color.MetRoughIsSpec) <= 1 && MaterialLobe == 3) {
            Color.MetRoughIsSpec = ToColorSpecPackedAdd(float3(0, 0, 3), Color.MetRoughIsSpec);
        }

        Color.InWaterDistance += hit.t;
        if(!GetFlag(hitDat.Tag, Thin)) {
            int WaterStageFlag = (Color.MetRoughIsSpec & 0x3800000) >> 23;
            if(GotFlipped) {
                if(MaterialLobe == 3 || (WaterStageFlag == 2 || WaterStageFlag == 4)) {
                    bsdf *= exp(-Color.InWaterDistance * CalculateExtinction(1.0f - hitDat.surfaceColor, hitDat.scatterDistance == 0.0f ? 1.0f : hitDat.scatterDistance));
                    if(!(WaterStageFlag == 2 || WaterStageFlag == 4)) WaterStageFlag = 3 + !Refracted;
                    Color.InWaterDistance = 0;
                }
            }
            if(MaterialLobe == 3 && (Refracted)) {
                Color.InWaterDistance = 0;
                if(GotFlipped) WaterStageFlag == 2;
                else WaterStageFlag = 1;
            }

            Color.MetRoughIsSpec = (Color.MetRoughIsSpec & ~(0x3800000)) | (WaterStageFlag << 23);
        }

        throughput *= bsdf;
    }


    ray.origin = USGNorm * NormalOffset + pos;//Offset the ray origin so we dont self intersect with the triangle we just bounced off of
    throughput = max(throughput, 0);
    [branch] if (CurBounce == 0 || GetBounceData(Color.MetRoughIsSpec) == 0) {//Setting textures for denosier to use
        #ifdef TrueBlack
            Color.Flags = packRGBE((CurBounce == 0) ? hitDat.surfaceColor : (unpackRGBE(Color.Flags) * hitDat.surfaceColor));
            Color.Data = float3((CurBounce == 0) ? throughput : (throughput * Color.Data.xyz));
        #else
            Color.Flags = packRGBE((CurBounce == 0) ? max(hitDat.surfaceColor, 0.005f) : (unpackRGBE(Color.Flags) * max(hitDat.surfaceColor, 0.005f)));
            Color.Data = float3((CurBounce == 0) ? max(throughput, 0.006f) : (max(throughput, 0.005f) * Color.Data.xyz));
        #endif
        PrevScreenData = float4(asfloat(octahedral_32(((hitDat.diffTrans != 0 || CurBounce == 0) && Refracted) ? -Geomnorm : Geomnorm)), asfloat(octahedral_32(((hitDat.diffTrans != 0 || CurBounce == 0) && Refracted) ? -norm : norm)),PrevScreenData.z + hit.t, asfloat((CurBounce == 0 ? ((uint)(MaterialIndex << 2) >> 2) : ((asuint(PrevScreenData.w) << 3) >> 3)) | ((CurBounce != 0 ? ((asuint(PrevScreenData.w) << 1) >> 30) :  (uint)MaterialLobe) << 29) | (Refracted << 31))); 
        Color.MetRoughIsSpec = ((Color.MetRoughIsSpec & ~(0xFC000000)) | (((CurBounce < 45 && UseASVGF && ((MaterialLobe == 3 && hitDat.roughness < 0.25f) || (hitDat.metallic == 1 && MaterialLobe == 0 && hitDat.roughness < 0.01f && CurBounce == 0))) ? 0 : (CurBounce + 2)) << 26)) | (Refracted << 22);  
        throughput = 1;  
    }   
    #ifdef RadianceCache
        #ifdef RadianceDebug
            if(CurBounce == 0) _DebugTex[id.xy] = float4(ray.origin, asfloat(octahedral_32(norm)));
        #endif
        if(CurBounce > 0 && (CacheInstance.pathLength >> 5) & 0x1) {
            float3 res2 = 0;
            if(MaterialLobe != 3 && (all(Color.Indirect == 0) || CurBounce < 3) && (hit.t >= CalcVoxelSize(ray.origin) * lerp(1.0f, 2.0f, random(326, pixel_index).x))) {// && (hit.t >= CalcVoxelSize(ray.origin) * lerp(1.0f, 2.0f, random(326, pixel_index).x))) {
                if(RetrieveCacheRadiance(CacheInstance, ray.origin, norm, res2)) {
                    // CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) + Color.Data * throughput * res2);//fabled "infinite bounce" - VERY hard to weight properly
                    Color.Indirect += (Color.throughput) * res2;
                    #ifdef HighSpeedRadCache
                        if(!all(Color.Indirect == 0)) {
                            if(!((int(id.x)/2 + int(id.y)/2 + curframe)%7==0)) return;
                            else throughput *= 7;
                        }
                    #endif
                }
            } else {
                #ifdef HighSpeedRadCache
                    if(!((int(id.x)/2 + int(id.y)/2 + curframe)%7==0)) return;
                #endif
            }
            CacheInstance.pathLength |= (1u << 6);
        } else if((!(MaterialLobe == 0 && hitDat.roughness < 0.04f) && MaterialLobe != 3)) CacheInstance.pathLength |= (1u << 5);

        if(CurBounce > 0) {
            if((CacheInstance.pathLength >> 6) & 0x1) {
                if((UseReSTIRGI && ReSTIRGIUpdateRate != 0 && RandomNums[id.xy].z != 0)) CacheInstance.CurrentIlluminance = EncodeRGB(DecodeRGB(CacheInstance.CurrentIlluminance) / (float)(ReSTIRGIUpdateRate - 1));
                if(!AddHitToCache(CacheInstance, PrevOrigin, random(324, pixel_index).y)) return;
                CacheInstance.CurrentIlluminance = 0;
            }
        }

        CacheInstance.Norm = octahedral_32(norm);
    #endif
    if (!validBSDFSample) return;//If the ray failed, we have no choice but to terminate this path
    pos = ray.origin;
      [branch] if (hitDat.specTrans == 0 && (UseNEE) && CurBounce < MaxBounce && (SecondaryBackgroundType == 1 || unitylightcount + LightMeshCount != 0)) {//Next event estimation
        float3 LightNorm;
        float3 LightPosition;
        int LightFormat = TRILIGHT;
        float3 Radiance;
        float RunningWeight = 1;
        float area = 1;
        float3 MiscInfo = 0;
        int AggTriIndex = 0;
        int SelectedLightGroup = 0;//0 = primitive, 1 = point, spot, etc., 2 = skybox
        int selectionoptions = 0;
        int selections[3] = {0,0,0};
        if(LightMeshCount != 0) selections[selectionoptions++] = 0;
        if(unitylightcount != 0) selections[selectionoptions++] = 1;
        if(SecondaryBackgroundType == 1) selections[selectionoptions++] = 2;
        RunningWeight = selectionoptions;
        SelectedLightGroup = selections[min(floor(random(114, pixel_index).x * (float)selectionoptions), selectionoptions - 1)];

        if (SelectedLightGroup == 1) {
            AggTriIndex = SelectUnityLight(pixel_index, RunningWeight, norm, pos, PrevDirection);
            LightData Light = _UnityLights[AggTriIndex];
            float sinPhi, cosPhi;
            LightPosition = Light.Position;
            LightNorm = Light.Direction;
            LightFormat = Light.Type;
            Radiance = Light.Radiance;
            float3 RandVec = float3(random(115, pixel_index), random(116, pixel_index).x);
            MiscInfo = float3(Light.Softness * 120.0f + 1, Light.SpotAngle);
            if(LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) {
                sincos(Light.ZAxisRotation, sinPhi, cosPhi);
            }
            [branch] switch (LightFormat) {
                case POINTLIGHT:
                    LightNorm = normalize(pos - LightPosition);
                    LightPosition += normalize(RandVec - 0.5f) * random(116, pixel_index).y * Light.Softness * 0.1f;//Soft Shadows
                break;
                case DIRECTIONALLIGHT:
                    LightPosition = pos + LightNorm;
                    LightNorm = -LightNorm;
                     sincos(RandVec.x * 2.0f * PI, RandVec.x, RandVec.y);
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy) * RandVec.z * Light.Softness* 0.01f;
                    if(Light.Softness* 0.01f > 0.001f) {
                        LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    }
                    if(UseTransmittanceInNEE) Radiance *= GetSkyTransmittance(pos, -LightNorm, 0, -LightNorm);
                    Radiance = DeSat(Radiance, 1.0f - SunDesaturate);
                break;
                case SPOTLIGHT:
                    LightPosition += normalize(RandVec - 0.5f) * random(116, pixel_index).y * Light.Softness * 0.1f;//Soft Shadows
                break;
                case AREALIGHTQUAD:
                    RandVec.xy = RandVec.xy * Light.SpotAngle - Light.SpotAngle / 2.0f;
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy);
                    LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    area = (Light.SpotAngle.x * Light.SpotAngle.y) / 2.0f;
                    if(hitDat.MatType == 3) Radiance = 0;
                break;
                case AREALIGHTDISK:
                    sincos(RandVec.x * 2.0f * PI, RandVec.x, RandVec.y);
                    RandVec.xy = mul(float2x2(cosPhi, -sinPhi, sinPhi, cosPhi), RandVec.xy) * RandVec.z * Light.SpotAngle.x;
                    LightPosition += ToWorld(GetTangentSpace2(LightNorm), normalize(float3(RandVec.x,0,RandVec.y))) * length(RandVec.xy);
                    area = PI * Light.SpotAngle.x * Light.SpotAngle.x;
                break;
            }
        } else if(SelectedLightGroup == 0) {
            #ifdef LBVH
                int MeshIndex;
                float4x4 MeshTransformInverse;
            #else
                int MeshIndex = SelectLightMeshSmart(pixel_index, RunningWeight, pos);
                float4x4 MeshTransformInverse = _MeshData[_LightMeshes[MeshIndex].LockedMeshIndex].W2L;
            #endif
            AggTriIndex = SelectLight(pixel_index, MeshIndex, RunningWeight, norm, pos, MeshTransformInverse, Radiance, LightPosition);
            #ifdef LBVH
                MeshTransformInverse = _MeshData[MeshIndex].W2L;
            #endif
            Radiance *= LEMEnergyScale;
            TrianglePos CurTri = triangle_get_positions(AggTriIndex);
            MeshTransformInverse = inverse(MeshTransformInverse);
            float3 a1 = mul((float3x3)MeshTransformInverse, CurTri.posedge1).xyz;
            float3 a2 = mul((float3x3)MeshTransformInverse, CurTri.posedge2).xyz;
            area = AreaOfTriangle(float3(0,0,0), a1, a2);
            LightPosition = mul(MeshTransformInverse, float4(LightPosition,1));
            LightNorm = normalize(mul((float3x3)MeshTransformInverse, normalize(cross(CurTri.posedge1, CurTri.posedge2))).xyz);
        } else {
            LightFormat = DIRECTIONALLIGHT;
            AggTriIndex = 0;
            Radiance = SampleLI(pixel_index, RunningWeight, LightNorm) * SecondaryBackgroundIntensity;
            LightPosition = pos - LightNorm;
        }


        if(AggTriIndex != -1) {
            float3 to_light = LightPosition - pos;

            float distance_to_light_squared = dot(to_light, to_light);
            float distance_to_light = sqrt(max(distance_to_light_squared, 0.0f));

            to_light = to_light / distance_to_light;

            if(LightFormat == SPOTLIGHT) {
                float3 LocalLight = ToLocal(GetTangentSpace(LightNorm), -to_light) * 0.5f + 0.5f;
                float2 AlignedUV = AlignUV(LocalLight.xz, float4(1,1,0,0), _UnityLights[AggTriIndex].IESTex);
                if(AlignedUV.x != -1) Radiance *= _IESAtlas.SampleLevel(my_point_clamp_sampler, AlignedUV, 0);
            }
            
            float SurfaceCos = dot(to_light, norm);//YES KEEP THIS, IT NOT ONLY IMPROVES PERFORMANCE BUT IT ALSO HELPS KEEPS THINGS LESS BIASED AS OTHERWISE THE NORMAL OFFSET CAN RESULT IN WRONG VISABILITY!
            if(SurfaceCos > 0) {
                float bsdf_pdf = 0.0f;
                float3 bsdf_value = 0.0f;
                float3 bsdf_diffuse = 0;
                #ifndef RadianceCache
                    if((UseReSTIRGI && CurBounce == 0) || (UseASVGF && (CurBounce == GetBounceData(Color.MetRoughIsSpec) - 2 && CurBounce > 0))) hitDat.surfaceColor = 1.0f;
                #endif
                bool validbsdfNEE;
                #ifdef RadianceCache
                    // if(CurBounce != 0) {
                        // if(hitDat.roughness > 0.6f || CurBounce == 0) validbsdfNEE = EvaluateBsdf(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_diffuse, pixel_index);
                        validbsdfNEE = EvaluateBsdf2(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_diffuse, pixel_index);
                        // bsdf_value /= bsdf_pdf;
                    //} else 
                    bsdf_pdf = 0;
                    validbsdfNEE = EvaluateBsdf(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_value, pixel_index);
                #else
                    validbsdfNEE = EvaluateBsdf(hitDat, PrevDirection, to_light, norm, bsdf_pdf, bsdf_value, pixel_index);
                #endif
                #ifndef RadianceCache
                    if((UseASVGF && (CurBounce == GetBounceData(Color.MetRoughIsSpec) - 2 && CurBounce > 0))) bsdf_value *= Color.Data.xyz;
                #endif

                if (validbsdfNEE) {
                    float NEE_pdf;
                    float3 Illum;
                    [branch]if (SelectedLightGroup == 1) {
                        NEE_pdf = distance_to_light_squared * abs(dot(to_light, LightNorm)) / area;
                        Illum = (Radiance * bsdf_value) / NEE_pdf * RunningWeight * ((LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) ? (MiscInfo.x) : 1.0f);
                        bsdf_diffuse = (Radiance * bsdf_diffuse) / NEE_pdf * RunningWeight * ((LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) ? (MiscInfo.x) : 1.0f);
                    } else if(SelectedLightGroup == 0) {        
                        NEE_pdf = (1.0f / ((abs(dot(to_light, LightNorm)) * area) / distance_to_light_squared)) / RunningWeight;
                        #ifndef LBVH
                            NEE_pdf /= LightMeshCount;
                        #endif
                        float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                        Illum = (Radiance * bsdf_value) / NEE_pdf * NEEMISWeight;
                        bsdf_diffuse = (Radiance * bsdf_diffuse) / NEE_pdf * NEEMISWeight;
                    } else {
                        NEE_pdf = HDRIParams.x * HDRIParams.y * equirectDirectionPdf(to_light) * (luminance(Radiance) / TotSum[0]);
                        float NEEMISWeight = power_heuristic(NEE_pdf, bsdf_pdf);
                        Illum = (Radiance * bsdf_value) / NEE_pdf * RunningWeight * NEEMISWeight;
                        bsdf_diffuse = (Radiance * bsdf_diffuse) / NEE_pdf * RunningWeight * NEEMISWeight;
                    }
                    #ifndef RadianceCache
                        Illum *= Color.throughput;
                    #endif
                    if(LightFormat == AREALIGHTQUAD || LightFormat == AREALIGHTDISK) {
                        Illum *= pow(saturate(dot(to_light, -LightNorm)), MiscInfo.x);
                        bsdf_diffuse *= pow(saturate(dot(to_light, -LightNorm)), MiscInfo.x);
                    }
                    if (LightFormat == SPOTLIGHT) {
                        bsdf_diffuse *= saturate(saturate(dot(to_light, -LightNorm)) * MiscInfo.y + MiscInfo.z);
                        Illum *= saturate(saturate(dot(to_light, -LightNorm)) * MiscInfo.y + MiscInfo.z);
                    }
                    float maxillum = max(max(Illum.x, Illum.y), Illum.z);
                    if(DoExposure) maxillum *= Exposure[0];
                    if(!UseRussianRoulette || (CurBounce == 0 && ImprovedPrimaryHit)) maxillum = 1;
                    Illum *= rcp(saturate(maxillum));
                    bsdf_diffuse *= rcp(saturate(maxillum));
                    if(luminance(Illum) != 0 && maxillum > random(117, pixel_index).y) {//NEE russian roulette, massively improves performance while giivng the same result
                        uint index3;
                        #ifdef RadianceCache
                            bool TempTemp = !(((CacheInstance.pathLength >> 5) & 0x1) && !((CacheInstance.pathLength >> 6) & 0x1));
                            if(UseReSTIRGI && !TempTemp && CurBounce == 0) Illum *= (bsdf_value == 0) ? 1 : rcp(bsdf_value);                    
                        #else
                            bool TempTemp = (CurBounce != GetBounceData(Color.MetRoughIsSpec) - 2);
                            if(UseReSTIRGI && CurBounce == 0) Illum *= (bsdf_value == 0) ? 1 : rcp(bsdf_value);                    
                        #endif            
                        ShadowRayData ShadRay = {pos, 
                                                        packRGBE(bsdf_diffuse), 
                                                        to_light, 
                                                        (LightFormat == DIRECTIONALLIGHT ? 10000.0f : distance_to_light - 0.01f) * (TempTemp ? 1 : -1),
                                                        Illum, 
                                                        pixel_index};
                        if(abs(ShadRay.t) > 0.001f) {
                            InterlockedAdd(BufferSizes[CurBounce].shadow_rays, 1, index3);
                            ShadowRaysBuffer[index3] = ShadRay;
                        }
                    }
                }
            }
        }
    }



    if (CurBounce > 0 && UseRussianRoulette && GetBounceData(Color.MetRoughIsSpec) != 0) {
        float3 AdjustedCol = throughput * (ImprovedPrimaryHit ? 1.0f : Color.Data.xyz);
        float p = saturate(max(AdjustedCol.x, max(AdjustedCol.y, AdjustedCol.z)));
        if (random(118, pixel_index).x > p)//Simple Russian Roulette
            return;
        throughput *= rcp(p);//rcp is a slightly faster but less accurate version of 1 / p, I decided the inaccuracy was worth the performance bump
        #ifdef RadianceCache
            CacheInstance.samples[0].x = EncodeRGB(clamp(bsdf * rcp(p),0,2));
        #endif
    } else {
        #ifdef RadianceCache
            CacheInstance.samples[0].x = EncodeRGB(clamp(bsdf,0,2));
        #endif
    }
    Color.throughput = throughput;

    if(CB) {
        uint index2;//Congrats, the ray will continue its path
        InterlockedAdd(BufferSizes[CurBounce + 1].tracerays, 1, index2);
        const RayData GlobalRay = {ray.origin, pixel_index, ray.direction, pdf,set2(hit)};
        [branch]if(CurBounce % 2 == 0) index2 += screen_width * screen_height;
        GlobalRays[index2] = GlobalRay;

    }
}
static const ColData InitCol = { 1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0};

#ifdef DX11
[numthreads(64, 1, 1)]
#else
[numthreads(32, 1, 1)]
#endif
void kernel_shade(uint3 id : SV_DispatchThreadID) {

    if (CurBounce != 0 && (id.x >= BufferSizes[CurBounce - 1].tracerays)) return;
    [branch]if(CurBounce % 2 == 1) id.x += screen_width * screen_height;
    const RayData GlobRay = GlobalRays[id.x];
    uint pixel_index = GlobRay.PixelIndex;
    id.xy = uint2(pixel_index % screen_width, pixel_index / screen_width);
    SmallerRay ray;
    RayHit bestHit = get2(GlobRay.hits);
    ray.origin = GlobRay.origin;
    ray.direction = GlobRay.direction;

    #ifdef HardwareRT
        if(bestHit.mesh_id != 9999999) {
            int2 Indexes = Unpack1To2(bestHit.mesh_id);
            int triangleOffset = SubMeshOffsets[MeshOffsets[Indexes.y].x + Indexes.x];
            bestHit.triangle_id += triangleOffset;
            bestHit.mesh_id = MeshOffsets[Indexes.y].y;
        }
    #endif
    ColData Color = InitCol;
    if(CurBounce > 0) Color = GlobalColors[pixel_index];
    else {
        CacheBuffer[pixel_index].pathLength = 0;
        CacheBuffer[pixel_index].CurrentIlluminance = 0;
    }





    if (bestHit.t == FarPlane) {//if ray goes into the void, sample skybox
        float3 Radiance, transmittance, debug = 0;
        float Stars;
        float2 uv;
        float mis = 1;
        float3 rayorig2 = ray.origin;
        rayorig2.y += bottom_radius;
        [branch]switch(BackgroundType) {
            case 0:
                Radiance = GetSkyRadiance(ray.origin, ray.direction, 0, SunDir, transmittance, debug);
                Radiance += debug;
                Radiance = pow(1.0f - exp(-Radiance / 1.0f * 10.0f), 1.0f);
                if (dot(ray.direction, SunDir) > cos(0.0235f / 2.0f)) Radiance += clamp((Radiance + transmittance * (1.5f / (PI * (0.0235f / 2.0f) * (0.0235f / 2.0f)))) / 100.0f, 0, 10.0f);
                Stars = stars(ray.origin, ray.direction, toSpherical(ray.direction.xzy).yz, 0) * (1.0f - tanh_approx(0));
                Stars *= max(12.0f * pow(1.0f - saturate(pow(RayleighPhaseFunction(dot(ray.direction, SunDir)) * MiePhaseFunction(0.8f, dot(ray.direction, SunDir)),0.1f)),2.0f) * transmittance * -dot(rayorig2, SunDir) / length(rayorig2), 0);
                Stars = pow(saturate(Stars), 2.0f);
                if(GetBounceData(Color.MetRoughIsSpec) <= 1) Radiance += Stars;

                if (all(Radiance < 10000.0f)) {
                    if (CurBounce == 0) Color.Direct = Color.throughput * DeSat(Radiance, 1.0f - SkyDesaturate) * BackgroundIntensity;
                    else if (CurBounce == 1) Color.Direct += Color.throughput * DeSat(Radiance, 1.0f - SkyDesaturate) * BackgroundIntensity;
                    #ifdef RadianceCache
                        else if(!((CacheBuffer[pixel_index].pathLength >> 5) & 0x1) || (((Color.MetRoughIsSpec & 0x3800000) >> 23) >= 3)) Color.Indirect += Color.throughput * DeSat(Radiance, 1.0f - SkyDesaturate) * BackgroundIntensity;
                        if(!UseReSTIRGI || ReSTIRGIUpdateRate == 0 || RandomNums[id.xy].z == 0) {
                            CacheBuffer[pixel_index].CurrentIlluminance = EncodeRGB(DecodeRGB(CacheBuffer[pixel_index].CurrentIlluminance)  + Radiance * BackgroundIntensity);
                            
                            AddHitToCache(CacheBuffer[pixel_index], ray.origin, random(324, pixel_index).y);
                        }
                            // AddMissToCache(CacheBuffer[pixel_index], Radiance * BackgroundIntensity);
                    #else
                        else Color.Indirect += Color.throughput * DeSat(Radiance, 1.0f - SkyDesaturate) * BackgroundIntensity;
                    #endif
                }
            break;
            case 1:
                uv = equirectDirectionToUv(ray.direction);
                uv = fmod(uv * HDRIScale + HDRILongLat / 360.0f, 1.0f);
                if(UseNEE && CurBounce > 0)
                    mis = power_heuristic(GlobRay.last_pdf, HDRIParams.x * HDRIParams.y * equirectDirectionPdf(ray.direction) * (luminance(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz) / TotSum[0]));
                if (CurBounce == 0) Color.Direct = _SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz * BackgroundIntensity;
                if (CurBounce == 1) Color.Direct += DeSat(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz * BackgroundIntensity,1.0f - SkyDesaturate) * mis;
                else Color.Indirect += Color.throughput * DeSat(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz * BackgroundIntensity,1.0f - SkyDesaturate) * mis;
                #ifdef RadianceCache
                    AddMissToCache(CacheBuffer[pixel_index], DeSat(_SkyboxTexture.SampleLevel(my_linear_clamp_sampler, uv, 0).xyz * BackgroundIntensity,1.0f - SkyDesaturate) * mis);
                #endif
            break;
            case 2:
                if (CurBounce == 0) Color.Direct = BackgroundColor * BackgroundIntensity;
                else if (CurBounce == 1) Color.Direct += BackgroundColor * BackgroundIntensity;
                else Color.Indirect += Color.throughput * BackgroundColor * BackgroundIntensity;
                #ifdef RadianceCache
                    // AddHitToCache(CacheBuffer[pixel_index], ray.origin, random(324, pixel_index).y);
                    AddMissToCache(CacheBuffer[pixel_index], BackgroundColor * BackgroundIntensity);
                #endif
            break;
        }
        if(CurBounce == 0) {
            Color.Data = float3(Color.Direct);
            Color.MetRoughIsSpec = (Color.MetRoughIsSpec & ~(0xFC000000)) |  ((1) << 26);  
        }
        if(GetBounceData(Color.MetRoughIsSpec) == 0) {
            ScreenSpaceInfo[id.xy] = float4(ScreenSpaceInfo[id.xy].xyz, asfloat((asuint(ScreenSpaceInfo[id.xy].w) << 1) >> 1));//PrevScreenData.z + hit.t, asfloat((CurBounce == 0 ? ((uint)(MaterialIndex << 2) >> 2) : ((asuint(PrevScreenData.w) << 3) >> 3)) | ((CurBounce != 0 ? ((asuint(PrevScreenData.w) << 1) >> 30) :  (uint)MaterialLobe) << 29) | (Refracted << 31))); 
            Color.MetRoughIsSpec = (Color.MetRoughIsSpec & ~(0xFC000000)) |  ((2) << 26);  

        }
        GlobalColors[pixel_index] = Color;
        if(UseReSTIRGI && CurBounce == 1 && GetBounceData(Color.MetRoughIsSpec) == 0) {
            ScreenSpaceInfo[id.xy] = float4(ScreenSpaceInfo[id.xy].xyz, asfloat(packRGBE(max(Color.throughput, 0.005f)))); 
        }
        return;
    }
    float2 BaseUv;
    int MaterialIndex;
    bool HitTerrain = false;
    MaterialData TempMat;
    [branch]if (TerrainExists && (bestHit.mesh_id == 9999999)) {//if hit terrain
        BaseUv = float2(bestHit.u, bestHit.v);
        float4 Mats = TerrainAlphaMap.SampleLevel(sampler_TerrainAlphaMap, BaseUv * (Terrains[bestHit.triangle_id].AlphaMap.xy - Terrains[bestHit.triangle_id].AlphaMap.zw) + Terrains[bestHit.triangle_id].AlphaMap.zw, 0);
        int x = 0;
        float minmat = Mats.x;
        if(minmat < Mats.y) {
            minmat = Mats.y;
            x = 1;
        }
        if(minmat < Mats.z) {
            minmat = Mats.z;
            x = 2;
        }
        if(minmat < Mats.a) {
            minmat = Mats.a;
            x = 3;
        }

        minmat = 0;
        float3 BaseCol = 0;
        MaterialIndex = MaterialCount + Terrains[bestHit.triangle_id].MatOffset;
        if(Mats.x > 0.001f) BaseCol += SampleTexture(BaseUv, SampleTerrainAlbedo, _Materials[MaterialIndex]) * Mats.x;
        if(Mats.y > 0.001f) BaseCol += SampleTexture(BaseUv, SampleTerrainAlbedo, _Materials[MaterialIndex + 1]) * Mats.y;
        if(Mats.z > 0.001f) BaseCol += SampleTexture(BaseUv, SampleTerrainAlbedo, _Materials[MaterialIndex + 2]) * Mats.z;
        if(Mats.w > 0.001f) BaseCol += SampleTexture(BaseUv, SampleTerrainAlbedo, _Materials[MaterialIndex + 3]) * Mats.w;
        MaterialIndex += x;
        TempMat = _Materials[MaterialIndex];
        BaseUv = BaseUv * TempMat.surfaceColor.xy + TempMat.transmittanceColor.xy;
        TempMat.surfaceColor = BaseCol;
        HitTerrain = true;
    } else {
        BaseUv = AggTris[bestHit.triangle_id].tex0 * (1.0f - bestHit.u - bestHit.v) + AggTris[bestHit.triangle_id].texedge1 * bestHit.u + AggTris[bestHit.triangle_id].texedge2 * bestHit.v;
        MaterialIndex = _MeshData[bestHit.mesh_id].MaterialOffset + AggTris[bestHit.triangle_id].MatDat;
        TempMat = _Materials[MaterialIndex];

        if(TempMat.AlbedoTex.x > 0) TempMat.surfaceColor *= SampleTexture(BaseUv, SampleAlbedo, TempMat);
        float3 TempCol = TempMat.surfaceColor;
        #ifndef DX11
            Unity_Hue_Degrees_float(TempCol, TempMat.Hue * 500.0f, TempMat.surfaceColor);
        #endif
        TempMat.surfaceColor *= TempMat.Brightness;
        TempCol = TempMat.surfaceColor;
        Unity_Saturation_float(TempCol, TempMat.Saturation, TempMat.surfaceColor);
        TempCol = TempMat.surfaceColor;
        Unity_Contrast_float(TempCol, TempMat.Contrast, TempMat.surfaceColor);
        TempMat.surfaceColor = saturate(TempMat.surfaceColor);
        TempMat.surfaceColor = lerp(TempMat.surfaceColor, TempMat.BlendColor, TempMat.BlendFactor);
    }


    #if DebugView != -1
            #if DebugView == 0
                if(CurBounce == 0) _DebugTex[id.xy] = HandleDebug(MaterialIndex);
            #elif DebugView == 1
                if(CurBounce == 0) _DebugTex[id.xy] = HandleDebug(bestHit.mesh_id);
            #elif DebugView == 2
                if(CurBounce == 0) _DebugTex[id.xy] = HandleDebug(bestHit.triangle_id);
            #elif DebugView == 3
                if(CurBounce == 0) _DebugTex[id.xy] = HandleDebug(TempMat.AlbedoTex.x);
            #endif
    #endif

    #ifdef LightMapping
        if(CurBounce == 0) TempMat.surfaceColor = 1;
    #endif
    if (TempMat.specTrans != 1 && TempMat.MetallicTex.x > 0) TempMat.metallic = pow(SampleTexture(BaseUv, SampleMetallic, TempMat), rcp(2.2f));
    if (TempMat.RoughnessTex.x > 0) {
        TempMat.roughness = saturate(pow(SampleTexture(BaseUv, SampleRoughness, TempMat), rcp(2.2f)));
        TempMat.roughness = (GetFlag(TempMat.Tag, InvertSmoothnessTexture) ? (1.0f - TempMat.roughness) : TempMat.roughness);
    }
    TempMat.metallic = saturate(TempMat.metallic);
    if(!all(TempMat.MetallicRemap == float2(0,1))) TempMat.metallic = (TempMat.metallic * (TempMat.MetallicRemap.y - TempMat.MetallicRemap.x)) + TempMat.MetallicRemap.x;
    if(!all(TempMat.RoughnessRemap == float2(0,1))) {
        if(GetFlag(TempMat.Tag, UseSmoothness)) TempMat.roughness = (TempMat.roughness * ((1.0f - TempMat.RoughnessRemap.x) - (1.0f - TempMat.RoughnessRemap.y))) + (1.0f - TempMat.RoughnessRemap.y);
        else TempMat.roughness = (TempMat.roughness * (TempMat.RoughnessRemap.y - TempMat.RoughnessRemap.x)) + TempMat.RoughnessRemap.x;
    }

    TempMat.roughness = max(TempMat.roughness, 0.00001f);
    #ifndef TrueBlack
        TempMat.surfaceColor = max(TempMat.surfaceColor, 0.005f);
    #endif

    #ifndef WhiteLights
        if(TempMat.emmissive > 0) {
            if (TempMat.EmissiveTex.x > 0) {
                float3 EmissCol = lerp(TempMat.EmissionColor, TempMat.surfaceColor, GetFlag(TempMat.Tag, BaseIsMap));
                float4 EmissTex = SampleTexture(BaseUv, SampleEmission, TempMat);
                if(!GetFlag(TempMat.Tag, IsEmissionMask)) {//IS a mask
                    TempMat.emmissive *= luminance(EmissTex.xyz);
                    EmissCol *= EmissTex.xyz;
                }
                TempMat.surfaceColor = lerp(TempMat.surfaceColor, EmissCol, saturate(TempMat.emmissive) * GetFlag(TempMat.Tag, ReplaceBase));
            }
        }
    #endif
    const bool InvalidateScreenSpaceInfo = ((!UseASVGF && CurBounce == 0));
    float4 PrevScreenData = InvalidateScreenSpaceInfo ? 0 : ScreenSpaceInfo[id.xy];
    float4 PrevPrev = PrevScreenData;
    #ifdef RadianceCache
        calcFinalColor(ray, Color, TempMat, bestHit, id.xy, GlobRay.last_pdf, pixel_index, MaterialIndex, BaseUv, PrevScreenData, CacheBuffer[pixel_index]);
    #else
        calcFinalColor(ray, Color, TempMat, bestHit, id.xy, GlobRay.last_pdf, pixel_index, MaterialIndex, BaseUv, PrevScreenData);
    #endif
    if((UseASVGF ^ InvalidateScreenSpaceInfo) && any(PrevPrev != PrevScreenData)) ScreenSpaceInfo[id.xy] = PrevScreenData;
    GlobalColors[pixel_index] = Color;

}





float IndirectBoost;

#ifdef HDRP
    Texture2DArray<float4> DiffuseGBuffer;
    Texture2DArray<float4> SpecularGBuffer;
    Texture2DArray<float4> NormalTexture;
#else
    Texture2D<float4> DiffuseGBuffer;
    Texture2D<float4> SpecularGBuffer;
    Texture2D<float4> NormalTexture;
#endif

#pragma kernel kernel_finalize

[numthreads(16, 16, 1)]
void kernel_finalize(uint3 id : SV_DispatchThreadID) {//Moved final accumulation into its own kernel, improves performance
    if (id.x >= screen_width || id.y >= screen_height) return;
    int final_pixel_index = id.y * screen_width + id.x;

    float3 GBufferCol = 1;
    [branch]if(DiffRes) {
        float2 UV = id.xy / float2(screen_width, screen_height);
        #ifdef HDRP
            float3 SpecularAlbedo = 0;
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo) == 0) ? 1 : (DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo);
        #else
            float3 SpecularAlbedo = SpecularGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0);
            GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo) == 0) ? 1 : ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo));
        #endif
    }
    float3 res = (GetBounceData(GlobalColors[final_pixel_index].MetRoughIsSpec) == 1) ? GlobalColors[final_pixel_index].Data.xyz : ((float)PartialRenderingFactor * ((GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) * GlobalColors[final_pixel_index].Data.xyz + pow(unpackRGBE(GlobalColors[final_pixel_index].PrimaryNEERay),2.2f)) / GBufferCol);
    // float3 res = (GlobalColors[final_pixel_index].Data.w == 0) ? GlobalColors[final_pixel_index].Data.xyz : ((float)PartialRenderingFactor * ((GlobalColors[final_pixel_index].Direct + GlobalColors[final_pixel_index].Indirect * IndirectBoost) * GlobalColors[final_pixel_index].Data.xyz) / GBufferCol);
    if (!all(res < 100000)) res = 0;
    #if defined(RadianceDebug) && defined(RadianceCache)
        res = 0;
        RetrieveCacheRadiance(CacheBuffer[final_pixel_index], _DebugTex[id.xy].xyz, i_octahedral_32(asuint(_DebugTex[id.xy].w)), res);
    #endif
    #if DebugView != -1
        Result[id.xy] = _DebugTex[id.xy];
    #else
        Result[id.xy] = float4(res, 1.0f);
    #endif
}


#pragma kernel TransferKernel
int Type;
[numthreads(1, 1, 1)]
void TransferKernel(uint3 id : SV_DispatchThreadID) {
    if(Type == 0) {
        BufferData[0] = uint3(ceil(BufferSizes[CurBounce].tracerays / 32.0f), 1, 1);
        if(CurBounce != 0) BufferSizes[CurBounce - 1].tracerays = BufferSizes[CurBounce].tracerays;
    } else {
        BufferData[0] = uint3(ceil(BufferSizes[CurBounce].shadow_rays / 32.0f), 1, 1);
    }

}

RWStructuredBuffer<float3> OutputBuffer;
RWStructuredBuffer<float3> AlbedoBuffer;
RWStructuredBuffer<float3> NormalBuffer;

#pragma kernel OIDNtoTTKernel
[numthreads(16, 16, 1)]
void OIDNtoTTKernel(uint3 id : SV_DispatchThreadID) {
    if(id.x >= screen_width || id.y >= screen_height) return;
    Result[id.xy] = float4(OutputBuffer[id.x + id.y * screen_width], 1);
}

#pragma kernel TTtoOIDNKernel
[numthreads(16, 16, 1)]
void TTtoOIDNKernel(uint3 id : SV_DispatchThreadID) {
    if(id.x > screen_width || id.y > screen_height) return;
    int pixel_index = id.x + id.y * screen_width;
    float3 GBufferCol = 1;
    float2 UV = id.xy / float2(screen_width, screen_height);
    #ifdef HDRP
        float3 SpecularAlbedo = 0;
        GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo) == 0) ? 1 : (DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo);
        NormalBuffer[pixel_index] = NormalTexture.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz * 2.0f - 1.0f;
    #else
        float3 SpecularAlbedo = SpecularGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0);
        GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo) == 0) ? 1 : ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo));
        NormalBuffer[pixel_index] = NormalTexture.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz * 2.0f - 1.0f;
    #endif
    AlbedoBuffer[pixel_index] = GBufferCol;
    OutputBuffer[id.x + id.y * screen_width] = Result[id.xy].xyz;
}



#pragma kernel TTtoOIDNKernelPanorama
[numthreads(16, 16, 1)]
void TTtoOIDNKernelPanorama(uint3 id : SV_DispatchThreadID) {
    if(id.x >= screen_width || id.y >= screen_height) return;
    int pixel_index = id.x + id.y * screen_width;
    float3 GBufferCol = 1;
    float2 UV = id.xy / float2(screen_width, screen_height);
    // #ifdef HDRP
    //     float3 SpecularAlbedo = 0;
    //     GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo) == 0) ? 1 : (DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz + SpecularAlbedo);
    //     NormalBuffer[pixel_index] = NormalTexture.SampleLevel(my_linear_clamp_sampler, float3(UV, 0), 0).xyz * 2.0f - 1.0f;
    // #else
    //     float3 SpecularAlbedo = SpecularGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0);
    //     GBufferCol = ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo) == 0) ? 1 : ((DiffuseGBuffer.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz + SpecularAlbedo));
    //     NormalBuffer[pixel_index] = NormalTexture.SampleLevel(my_linear_clamp_sampler, UV, 0).xyz * 2.0f - 1.0f;
    // #endif
        NormalBuffer[pixel_index] = i_octahedral_32(ScreenSpaceInfo[id.xy].y);
    AlbedoBuffer[pixel_index] = unpackRGBE(GlobalColors[pixel_index].Flags);
    OutputBuffer[id.x + id.y * screen_width] = Result[id.xy].xyz;
}
