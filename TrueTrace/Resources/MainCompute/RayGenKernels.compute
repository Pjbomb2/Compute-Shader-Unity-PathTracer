#include "../GlobalDefines.cginc"
#ifndef DX11
    #pragma use_dxc
#endif
#include "CommonData.cginc"

#ifdef HDRP
Texture2DArray<float2> MotionVectors;
Texture2DArray<float3> NormalTex;
Texture2DArray<float> Depth;
#else
Texture2D<float2> MotionVectors;
Texture2D<float3> NormalTex;
Texture2D<float> Depth;
#endif


static const ColData InitCol = { 1,1,1,0,0,0,0,0,0,0,0,0,1,1,1,0};
const static RayHit tempray = CreateRayHit();


bool UseASVGFAndReSTIR;
#pragma kernel Generate
[numthreads(16, 16, 1)]
void Generate(uint3 id : SV_DispatchThreadID) {

    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;
    float2 jitter = ((random(0, pixel_index) - 0.5));
    if(OIDNGuideWrite || UseASVGFAndReSTIR) jitter = 0;
    float2 uv = float2((id.xy + jitter) / float2(screen_width, screen_height) * 2.0f - 1.0f);
    SmallerRay ray = CreateCameraRay(uv, pixel_index);
    RayData globray = {ray.origin + NearPlane * ray.direction, pixel_index, ray.direction, 0, 0,0,asuint(FarPlane),0};
    GlobalRays[pixel_index] = globray;
}

#pragma kernel GIReTraceKernel
[numthreads(16, 16, 1)]
void GIReTraceKernel(uint3 id : SV_DispatchThreadID, uint3 id2 : SV_GroupThreadID, uint3 id3 : SV_GroupID, uint id4 : SV_GroupIndex) {
    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;

    float2 uv = float2((id.xy) / float2(screen_width, screen_height));
    SmallerRay ray = CreateCameraRay(uv * 2.0f - 1.0f, pixel_index);
    RayData globray = {ray.origin + NearPlane * ray.direction, pixel_index, ray.direction, 0, 0,0,asuint(FarPlane),0};
    RandomNumsWrite[id.xy] = float4(frames_accumulated, pixel_index, 0, 0);

    if(curframe % ReSTIRGIUpdateRate == pixel_index % ReSTIRGIUpdateRate) {
        #ifdef HDRP
            float2 MotionVector = MotionVectors[int3(id.xy,0)].xy;
        #else
            float2 MotionVector = MotionVectors.SampleLevel(my_linear_clamp_sampler, uv, 0).xy;
        #endif
        int2 prevIndex = int2(floor(((float2(id.xy) + 0.5) * float2(rcp(screen_width), rcp(screen_height)) - MotionVector) * float2(screen_width, screen_height)));
        if (RandomNums[prevIndex].z == 0 && (ReservoirA[uint3(prevIndex, 0)].w >> 24) != 3 && prevIndex.x >= 0 && prevIndex.x < screen_width && prevIndex.y >= 0 && prevIndex.y < screen_height) {
            RandomNumsWrite[id.xy] = float4(int2((ReservoirA[uint3(prevIndex, 0)].w & 0x00FFFFFF), ReservoirA[uint3(prevIndex, 0)].z), (ReservoirA[uint3(prevIndex, 0)].w >> 24) + 1,  1);
        }
    }

    GlobalRays[pixel_index] = globray;
}

bool DoPanorama;
float2 Segment;
#pragma kernel GeneratePanorama
[numthreads(16, 16, 1)]
void GeneratePanorama(uint3 id : SV_DispatchThreadID) {
    if (id.x >= screen_width || id.y >= screen_height) return;
    const uint pixel_index = id.y * screen_width + id.x;
    float2 jitter = ((random(0, pixel_index) - 0.5));
    if(OIDNGuideWrite) jitter = 0;
    float2 uv = float2((id.xy + jitter) / float2(screen_width, screen_height));
    SmallerRay ray;
    if(DoPanorama) {
        uv.y = 1.0f - uv.y;
        uv.x = (uv.x * (Segment.y - Segment.x)) + Segment.x;
        uv.x = 1.0f - uv.x;

        ray = CreateRay(mul(CamToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz + NearPlane * normalize(equirectUvToDirection(uv)), normalize(equirectUvToDirection(uv)));
        _DebugTex[id.xy] = float4(uv, 0, 1);
    } else {
        uv.x = ((uv.x * (Segment.y - Segment.x)) + Segment.x);
        uv = (uv * 2.0f) - 1.0f;

        ray = CreateCameraRay(uv, pixel_index);
        ray.origin = ray.origin + NearPlane * ray.direction;
    }
    RayData globray = {ray.origin, pixel_index, ray.direction, 0, 0,0,asuint(FarPlane),0};
    GlobalRays[pixel_index] = globray;
}


#pragma kernel CacheResolve
[numthreads(256, 1, 1)]
void CacheResolve(uint3 id : SV_DispatchThreadID) {
    VoxelDataBufferA.Store4(id.x * 16, 0);
    HashEntriesBufferA[id.x] = 0;
}